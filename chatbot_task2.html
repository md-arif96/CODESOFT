<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Task 2: Unbeatable Tic-Tac-Toe AI (Minimax)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            color: #f9fafb;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .game-container {
            width: 90%;
            max-width: 400px;
            background-color: #374151; /* Medium dark container */
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            aspect-ratio: 1 / 1; /* Keep the board square */
            margin: 1rem auto;
            border: 5px solid #4f46e5; /* Indigo border */
            border-radius: 0.5rem;
        }
        .cell {
            background-color: #4b5563; /* Cell background */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: 900;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border-radius: 0.25rem;
        }
        .cell:hover:not(.occupied) {
            background-color: #6b7280;
        }
        .cell.x-player { color: #f87171; } /* Reddish for X (User) */
        .cell.o-player { color: #34d399; } /* Greenish for O (AI) */

        .message-box {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-weight: 700;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .winning-cell {
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { background-color: #facc15; }
            to { background-color: #eab308; }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1 class="text-3xl font-extrabold mb-4 text-indigo-400">Unbeatable Tic-Tac-Toe AI</h1>
        <p class="text-sm mb-4 text-gray-300">CodSoft AI Internship - Task 2 (Minimax Algorithm)</p>

        <!-- Game Board -->
        <div id="board" class="board">
            <!-- 9 cells generated by JS -->
        </div>

        <!-- Status Message Box -->
        <div id="status-message" class="message-box bg-gray-700 text-gray-100">
            Click any cell to start. You are X.
        </div>

        <!-- Control Button -->
        <button id="reset-btn" 
                class="mt-4 w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-lg transition duration-200">
            Reset Game
        </button>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('board');
            const messageElement = document.getElementById('status-message');
            const resetBtn = document.getElementById('reset-btn');

            let board; // Represents the 3x3 game state: ['X', 'O', null, ...]
            let currentPlayer = 'X';
            let isGameOver = false;

            // --- Game Logic Functions ---

            /** Initializes the board and UI. */
            function initializeGame() {
                board = Array(9).fill(null);
                currentPlayer = 'X';
                isGameOver = false;
                
                boardElement.innerHTML = ''; // Clear previous board
                messageElement.textContent = "Your turn (X).";
                messageElement.className = "message-box bg-gray-700 text-gray-100"; // Reset style

                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.index = i;
                    cell.addEventListener('click', () => handleCellClick(i));
                    boardElement.appendChild(cell);
                }
            }

            /** Checks for a win condition or a tie. */
            function checkWinner(currentBoard) {
                const winConditions = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                    [0, 4, 8], [2, 4, 6]             // Diagonals
                ];

                for (const condition of winConditions) {
                    const [a, b, c] = condition;
                    if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
                        return { winner: currentBoard[a], line: condition };
                    }
                }

                if (currentBoard.every(cell => cell !== null)) {
                    return { winner: 'Tie', line: null };
                }

                return null;
            }

            /** Updates the UI after a move. */
            function updateUI(index, player) {
                const cellElement = boardElement.children[index];
                cellElement.textContent = player;
                cellElement.classList.add('occupied', player === 'X' ? 'x-player' : 'o-player');
                cellElement.removeEventListener('click', () => handleCellClick(index));
            }

            /** Marks the winning cells and displays the result. */
            function finalizeGame(result) {
                isGameOver = true;
                if (result.winner === 'Tie') {
                    messageElement.textContent = "Game Over: It's a Tie!";
                    messageElement.className = "message-box bg-yellow-600 text-white";
                } else {
                    messageElement.textContent = Game Over: ${result.winner} Wins!;
                    messageElement.className = result.winner === 'X' ? 
                                              "message-box bg-red-600 text-white" : 
                                              "message-box bg-green-600 text-white";
                    
                    // Highlight winning line
                    result.line.forEach(i => {
                        boardElement.children[i].classList.add('winning-cell');
                    });
                }
                // Disable remaining cells
                Array.from(boardElement.children).forEach(cell => {
                    cell.removeEventListener('click', () => handleCellClick(parseInt(cell.dataset.index)));
                });
            }


            // --- Minimax AI Algorithm ---
            
            // Scores for minimax: X (user) wants minimum score, O (AI) wants maximum score
            const scores = {
                'X': -10, // Maximize loss for X
                'O': 10,  // Maximize win for O
                'Tie': 0
            };

            /** The core Minimax algorithm */
            function minimax(currentBoard, isMaximizing) {
                const result = checkWinner(currentBoard);
                
                // Base case: if game is over, return the score
                if (result !== null) {
                    return scores[result.winner];
                }

                const availableMoves = currentBoard
                    .map((cell, index) => cell === null ? index : null)
                    .filter(index => index !== null);

                if (isMaximizing) {
                    // O's turn (Maximizer)
                    let bestScore = -Infinity;
                    for (const index of availableMoves) {
                        currentBoard[index] = 'O';
                        const score = minimax(currentBoard, false);
                        currentBoard[index] = null; // Backtrack
                        bestScore = Math.max(score, bestScore);
                    }
                    return bestScore;
                } else {
                    // X's turn (Minimizer)
                    let bestScore = Infinity;
                    for (const index of availableMoves) {
                        currentBoard[index] = 'X';
                        const score = minimax(currentBoard, true);
                        currentBoard[index] = null; // Backtrack
                        bestScore = Math.min(score, bestScore);
                    }
                    return bestScore;
                }
            }

            /** AI decision function: finds the best move using Minimax. */
            function findBestMove() {
                let bestScore = -Infinity;
                let bestMove = -1;
                
                const availableMoves = board
                    .map((cell, index) => cell === null ? index : null)
                    .filter(index => index !== null);

                // Iterate through all possible moves and run Minimax
                for (const index of availableMoves) {
                    board[index] = 'O'; // Make the move
                    const score = minimax(board, false); // Evaluate the resulting board (Minimizing player's turn next)
                    board[index] = null; // Undo the move (Backtrack)

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = index;
                    }
                }
                return bestMove;
            }


            // --- Game Flow Control ---

            /** Handles user clicks and triggers AI move. */
            function handleCellClick(index) {
                if (isGameOver || board[index] !== null) {
                    return;
                }

                // 1. User Move (X)
                board[index] = 'X';
                updateUI(index, 'X');
                
                let result = checkWinner(board);
                if (result) {
                    finalizeGame(result);
                    return;
                }
                
                messageElement.textContent = "AI's turn (O)...";

                // 2. AI Move (O) - Executed after a small delay for user experience
                setTimeout(() => {
                    if (!isGameOver) {
                        const bestMove = findBestMove();
                        
                        if (bestMove !== -1) {
                            board[bestMove] = 'O';
                            updateUI(bestMove, 'O');
                            result = checkWinner(board);

                            if (result) {
                                finalizeGame(result);
                            } else {
                                messageElement.textContent = "Your turn (X).";
                            }
                        }
                    }
                }, 500); // 500ms delay
            }


            // --- Initialization and Events ---

            resetBtn.addEventListener('click', initializeGame);

            // Start the game when the page loads
            initializeGame();
        });
    </script>
</body>
</html>